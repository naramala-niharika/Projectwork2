# Precise Detection and Analysis of Brain Tumor Progression Using CNN
This research focuses on using Convolutional Neural Networks (CNNs) to accurately detect and classify brain tumor progression from MRI scans. The framework enhances diagnostic reliability through deep learning, transfer learning, and attention mechanisms. It outperforms traditional methods in accuracy, sensitivity, and specificity, aiding radiologists in precise tumor assessment. The dataset includes high-quality CT and MRI scans with labeled tumor types, supporting AI-based brain tumor detection and segmentation research.


## Featuresf the CNN-Based Brain Tumor Diagnostic System  


- This research included 1000 identical Magnetic Resonance Images, collected from multiple sources.
    - glioma Tumor
    - Putuitary Tumor
    - Moningioma Tumor
    - No Tumor

1. **Automated Tumor Detection and Classification**  
2. **Integration of Deep Learning and CNNs**  
3. **Enhanced Diagnostic Accuracy and Precision**  
4. **Data Augmentation for Improved Model Generalization**  
5. **Transfer Learning for Efficient Feature Extraction**  
6. **Attention Mechanisms for Focused Analysis**  
7. **MRI and CT Scan Integration for Comprehensive Assessment**  
8. **Automated Feature Extraction Eliminating Manual Processing**  
9. **Robust Performance Evaluation Using Multiple Metrics**  
10. **Support for AI-Based Medical Imaging Research**  
11. **Personalized Treatment Planning Assistance**  
12. **Reduction of Human Error and Observer Variability**  
13. **High-Speed Image Processing for Rapid Diagnosis**  
14. **Scalability and Adaptability for Various Tumor Types**  
15. **Contribution to Medical AI Software Development**  

## Requirements

- Python 
- GPU (check availability and utilizes it if present)
- Environment with the specified Python libraries (Jupyter Notebooks, Google Colab)
- Required Python packages: 
 pandas, matplotlib, seaborn, keras, tensorflow, scikit-learn.

## Architecture Diagram/Flow
![ar](https://github.com/user-attachments/assets/bab9bc98-0943-447e-8557-1b879c828abc)

## Installation

1. Install the required python libraries:
2. 
   ```shell
   !pip install pandas numpy matplotlib seaborn tensorflow scikit-learn
3. Install the required packages:

   ```shell
   pip install keras
4. If you face any issues related to GPU support or TensorFlow installation, you might need to install specific versions or configure GPU drivers.

## Usage

1. Navigate to Google Colab and Create a new notebook.
   ```shell
   https://colab.research.google.com/
   ```

2. Upload the dataset of four classes to Google drive .
    ```
    from google.colab import drive
    drive.mount('/content/drive')
    ```

3. After uploading the dataset in the Google Drive, Mount Drive with the Google Colab repository.

4. Execute the  Disease Detection script in the Colab notebook, which may involve adapting the script to run within a notebook environment.

5. Make sure that the Retinopathy Disease Prediction script runs within the Colab notebook environment and required packages are installed in the Colab environment using the following commands.
    ```
    !pip install package_name
    ```

6. Display the prediction results directly within the Colab notebook.

7. Include visualizations, such as predicted classes or probability scores, to enhance result interpretation.

8. Repeat the process by providing new inputs, changing the optimizer, Ephocs and with different  images.

### Mathematical Equations
#### 1. Accuracy:
The accuracy measures the overall correctness of the classification model. It is
the ratio of correctly predicted instances to the total instances.

```
Accuracy = Number of Correct Predictions/Total Number of Predictions
```

#### 2. Precision:
Precision is the ratio of correctly predicted positive observations to the total
predicted positives. It is a measure of how many of the predicted positive
instances are actually positive.
```
Precision = True Positives/True Positives + False Positives
```

#### 3. F1 Score:
The F1 Score is the harmonic mean of precision and recall, providing a balance
between the two metrics.
```
F1 Score = 2×(Precision×Recall/Precision + Recall)
```
4. Confusion Matrix:
The confusion matrix is a table that describes the performance of a classification
model. It contains information about true positive, true negative, false positive,
and false negative predictions.
~~~
[True Negative (TN) False Positive (FP)
False Negative (FN) True Positive (TP)]
~~~
5. Loss Function:
A loss function, in the context of machine learning, quantifies the difference
between the predicted values generated by a model and the actual ground truth,
serving as a measure of the model's performance during training.
~~~
Lcross-entropy(xi) = -(yi log(f(xi))+(1-yi)log(1-f(xi)))
~~~

## Program:
### Import packages
Imports essential libraries for data manipulation, visualization, and deep learning using TensorFlow and Keras, while also configuring some settings for plotting.

```python
import os, glob
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint
from sklearn.utils import class_weight
from sklearn.model_selection import train_test_split
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.applications.efficientnet import preprocess_input
from tensorflow.keras.applications import EfficientNetB0
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Dense, GlobalAveragePooling2D, Dropout
from tensorflow.keras.optimizers import Adam
from sklearn.metrics import classification_report, confusion_matrix, roc_curve, auc
import tensorflow as tf
import random
import pandas as pd
import cv2
sns.set()
```
### Read and add all data in an array
```python
#I imported it locally, however, It can be done with any method preferred. 
dataDirectory = "../data"

ctHealthyPath = glob.glob(os.path.join(dataDirectory, "CT", "Healthy", "*.jpg"))
ctTumorPath  = glob.glob(os.path.join(dataDirectory, "CT", "Tumor", "*.jpg"))

mriHealthyPath = glob.glob(os.path.join(dataDirectory, "MRI", "Healthy", "*.jpg"))
mriTumorPath  = glob.glob(os.path.join(dataDirectory, "MRI", "Tumor", "*.jpg"))


data = []

#CT Scan: Healthy and Tumor
for path in ctHealthyPath:
    data.append((path, 0, "CT"))
for path in ctTumorPath:
    data.append((path, 1, "CT"))

#MRI Scan: Healthy and Tumor
for path in mriHealthyPath:
    data.append((path, 0, "MRI"))
for path in mriTumorPath :
    data.append((path, 1, "MRI"))

#Checking the number of entries collected in array
print("Number of Data entries:")
print("CT Healthy: ", len(ctHealthyPath))
print("CT Tumor: ", len(ctTumorPath))
print("MRI Healthy: ", len(mriHealthyPath))
print("MRI Tumor: ", len(mriTumorPath))
print("Total images in Data:", len(data))
```
### Generate TF Dataset
```python
data = tf.keras.utils.image_dataset_from_directory(PATH,
                                                batch_size = 32,
                                                image_size=(128, 128),
                                                shuffle=True,
                                                seed=42,)

class_names = data.class_names
```
#### spplitting into train and test

```py
df_train_val, df_test = train_test_split(
    df,
    test_size=0.1,
    random_state=42,
    stratify=df['label']
)

# further splitting into train and validation
df_train, df_val = train_test_split(
    df_train_val,
    test_size=0.1,
    random_state=42,
    stratify=df_train_val['label'] 
)

df_train = df_train.reset_index(drop=True)
df_val = df_val.reset_index(drop=True)
df_test = df_test.reset_index(drop=True)

# checking label distribution
for dataset, name in zip([df_train, df_val, df_test], ['Training', 'Validation', 'Testing']):
    print(f"\n{name} set label distribution:")
    print(dataset['label'].value_counts(normalize=True))
```
##  Data Visualization
```py
fig, axes = plt.subplots(1, 2, figsize=(12, 4))

df = pd.DataFrame(data, columns=['path', 'label', 'modality'])

sns.countplot(x='label', data=df, ax=axes[0], color="#b12f1e")
axes[0].set_title("Label Distribution")

sns.countplot(x='modality', data=df, ax=axes[1], color="#7148b4")
axes[1].set_title("Modality Distribution")

plt.tight_layout()
plt.show()
```
##  Displaying the MRI and CT scans: Tumor & Healthy images¶

```py
def show_random_images(df, label_filter, modality_filter, n=4):
    subset = df[(df['label'] == label_filter) & (df['modality'] == modality_filter)]
    n_to_show = min(n, len(subset))
    
    sample_rows = subset.sample(n=n_to_show, random_state=42)
    
    plt.figure(figsize=(12, 4))
    for i, (_, row) in enumerate(sample_rows.iterrows(), start=1):
        img_path = row['path']
        img = cv2.imread(img_path)
    
        plt.subplot(1, n_to_show, i)
        plt.imshow(img)
        
        lbl = "Tumor" if row['label'] == 1 else "Healthy"
        mod = row['modality']
        plt.title(f"{lbl} ({mod})")
        plt.axis('off')
    
    plt.tight_layout()
    plt.show()
```
```py
show_random_images(df, label_filter=1, modality_filter='CT', n=2)
show_random_images(df, label_filter=0, modality_filter='CT', n=2)
show_random_images(df, label_filter=1, modality_filter='MRI', n=2)
show_random_images(df, label_filter=0, modality_filter='MRI', n=2)

```
## Processing data
##   a) Preparing the data
```py
label_mapping = {0: 'Healthy', 1: 'Tumor'}

df_train['label'] = df_train['label'].map(label_mapping)
df_val['label'] = df_val['label'].map(label_mapping)
df_test['label'] = df_test['label'].map(label_mapping)
```
```py
IMAGE_SIZE = (224, 224)
BATCH_SIZE = 32

# Image/Data generator
def data_generator(df, image_size):
    for index, row in df.iterrows():
        # Load image and resize
        image = tf.io.read_file(row['path'])
        image = tf.image.decode_image(image, channels=3)
        image = tf.image.resize(image, image_size)
        
        # since I am using EfficientNet, I am using their preprocess_input
        image = preprocess_input(image)
        
        label = 0 if row['label'] == 'Healthy' else 1
        
        yield image, label

train_dataset = tf.data.Dataset.from_generator(
    generator=lambda: data_generator(df_train, IMAGE_SIZE),
    output_signature=(
        tf.TensorSpec(shape=(224, 224, 3), dtype=tf.float32),
        tf.TensorSpec(shape=(), dtype=tf.int32)
    )
).batch(BATCH_SIZE).prefetch(buffer_size=tf.data.AUTOTUNE).repeat()

# validation dataset
validation_dataset = tf.data.Dataset.from_generator(
    generator=lambda: data_generator(df_val, IMAGE_SIZE),
    output_signature=(
        tf.TensorSpec(shape=(224, 224, 3), dtype=tf.float32),
        tf.TensorSpec(shape=(), dtype=tf.int32)
    )
).batch(BATCH_SIZE).prefetch(buffer_size=tf.data.AUTOTUNE).repeat()

# Testing Dataset
test_dataset = tf.data.Dataset.from_generator(
    generator=lambda: data_generator(df_test, IMAGE_SIZE),
    output_signature=(
        tf.TensorSpec(shape=(224, 224, 3), dtype=tf.float32),
        tf.TensorSpec(shape=(), dtype=tf.int32)
    )
).batch(BATCH_SIZE).prefetch(buffer_size=tf.data.AUTOTUNE)
```
### b) Establishing callbacks

```py
early_stop = EarlyStopping(
    monitor='val_loss', 
    patience=5,                 
    restore_best_weights=True  
)

checkpoint = ModelCheckpoint(
    'best_model.keras', 
    monitor='val_accuracy', 
    save_best_only=True,     
    verbose=1                  
)

reduce_lr = ReduceLROnPlateau(
    monitor='val_loss',
    factor=0.5,
    patience=3,
    min_lr=1e-6,
    verbose=1
)

callbacks = [early_stop, checkpoint, reduce_lr]

```
### c) Establishing class weights¶

```py
class_weights = class_weight.compute_class_weight(
    class_weight='balanced',
    classes=np.unique(df_train['label']),
    y=df_train['label']
)

class_weight_dict = {i: weight for i, weight in zip(np.unique(df_train['label']), class_weights)}

class_indices = train_generator.class_indices
class_weights_int = {index: class_weight_dict[class_name] for class_name, index in class_indices.items()}
```
### 4) EfficientNetB0 Model
```py
base_model = EfficientNetB0(weights='imagenet', include_top=False, input_shape=(224, 224, 3))
base_model.trainable = False 

x = base_model.output
x = GlobalAveragePooling2D()(x)
x = Dense(512, activation='relu')(x)
x = Dropout(0.5)(x)
predictions = Dense(1, activation='sigmoid')(x)

model = Model(inputs=base_model.input, outputs=predictions)

model.compile(
    optimizer=Adam(learning_rate=1e-4),
    loss='binary_crossentropy',
    metrics=['accuracy']
)
```
```py
steps_per_epoch = len(df_train) // BATCH_SIZE
validation_steps = len(df_val) // BATCH_SIZE

history = model.fit(
    train_dataset,
    validation_data=validation_dataset,
    steps_per_epoch=steps_per_epoch,
    validation_steps=validation_steps,
    epochs=3,
    callbacks=callbacks
)
```
### 4) Evaluating the Model

```py
plt.figure(figsize=(14, 6))

plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'], label='Train Accuracy', color='blue')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy', color='orange')
plt.title('Model Accuracy')
plt.ylabel('Accuracy')
plt.xlabel('Epoch')
plt.legend(loc='lower right')

plt.subplot(1, 2, 2)
plt.plot(history.history['loss'], label='Train Loss', color='blue')
plt.plot(history.history['val_loss'], label='Validation Loss', color='orange')
plt.title('Model Loss')
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.legend(loc='upper right')

plt.tight_layout()
plt.show()
```
```py
test_generator.reset()

pred_probs = model.predict(test_generator)
pred_classes = (pred_probs > 0.5).astype(int).reshape(-1)

true_classes = test_generator.classes
class_labels = list(test_generator.class_indices.keys())

report = classification_report(true_classes, pred_classes, target_names=class_labels)
print("Classification Report:\n", report)

cm = confusion_matrix(true_classes, pred_classes)
plt.figure(figsize=(6, 4))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
            xticklabels=class_labels, yticklabels=class_labels)
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('Confusion Matrix')
plt.show()

fpr, tpr, thresholds = roc_curve(true_classes, pred_probs)
roc_auc = auc(fpr, tpr)

plt.figure(figsize=(8, 6))
plt.plot(fpr, tpr, color='darkorange',
         lw=2, label=f'ROC curve (AUC = {roc_auc:.2f})')
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic (ROC)')
plt.legend(loc="lower right")
plt.show()
```


## Output:
###   Modality Distribution
![image](https://github.com/user-attachments/assets/8b7aca81-31cf-49f1-b5c7-97880bf51285)


### ROC
![image](https://github.com/user-attachments/assets/eded5d56-7baf-44a0-8b9b-40313e3b9cdb)




### Loss and Accuracy
![image](https://github.com/user-attachments/assets/1c4a8855-f47d-4e9c-95b0-de7da9800ccb)


### Confusion Matrix
![image](https://github.com/user-attachments/assets/1f1b9692-deb2-4c64-b622-b2b22d2b61fd)



### Predicted Output
![image](https://github.com/user-attachments/assets/6ac6eec0-6c02-4376-93ee-0ba996ef1561)

![image](https://github.com/user-attachments/assets/9cfc1dc2-0de0-4b13-bce3-0a2a4646453c)

![image](https://github.com/user-attachments/assets/9610bfb1-a835-4266-9891-58917bb48f45)

![image](https://github.com/user-attachments/assets/e621effd-105d-4355-a5fb-e8ab9a265ef5)



## Result:
The CNN-based brain tumor diagnostic system delivers outstanding results in classification accuracy, achieving superior performance in detecting and differentiating tumor types. It demonstrates high sensitivity and specificity, effectively minimizing false positives and false negatives. The model's robust ROC-AUC scores confirm its strong discriminatory power, while improved F1-scores and precision ensure a balanced performance between recall and accuracy. Compared to traditional machine learning and deep learning approaches, this system outperforms them in diagnostic precision, reliability, and efficiency. Additionally, the integration of data augmentation and transfer learning enhances generalization capabilities, allowing the model to perform effectively even with limited datasets. The system also significantly reduces diagnostic time by automating image processing, enabling faster clinical decision-making. Its advanced segmentation techniques provide precise tumor localization, contributing to improved inter-observer consistency and reducing diagnostic variability among radiologists. Ultimately, this CNN-based approach enhances clinical utility by supporting radiologists in accurate tumor assessment, facilitating personalized treatment planning, and improving overall patient outcomes.




### References
1. N. S. Gupta, S. K. Rout, S. Barik, R. R. Kalangi, and B. Swampa, “Enhancing Heart Disease Prediction Accuracy Through Hybrid Machine Learning Methods,” *EAI Endorsed Trans IoT*, vol. 10, Mar. 2024.  
2. A. A. BIN ZAINUDDIN, “Enhancing IoT Security: A Synergy of Machine Learning, Artificial Intelligence, and Blockchain,” *Data Science Insights*, vol. 2, no. 1, Feb. 2024.  
3. Brain Tumor Detection and Classification Using Convolutional Neural Network and Deep Neural Network, *IEEE Xplore* (2025). [Link](https://ieeexplore.ieee.org/document/9132874)  
4. Brain Tumor Image Segmentation Using Deep Networks, *IEEE Xplore* (2025). [Link](https://ieeexplore.ieee.org/document/9171998)  
5. Brain Tumor Detection from MRI Images Using Deep CNN, *IEEE Xplore* (2024). [Link](https://ieeexplore.ieee.org/document/10142928)  
6. Automated Brain Tumor Segmentation and Classification in MRI Using YOLO-Based Deep Learning, *IEEE Xplore* (2025). [Link](https://ieeexplore.ieee.org/document/10415378)  
7. Brain Tumor Detection Using Convolutional Neural Network, *IEEE Xplore* (2025). [Link](https://ieeexplore.ieee.org/document/8934561)  
8. Brain Tumor Detection Using Various Deep Learning Algorithms, *IEEE Xplore* (2025). [Link](https://ieeexplore.ieee.org/document/9642649)  
9. Brain Tumor Detection Using YOLOv5 and Faster R-CNN, *IEEE Xplore* (2025). [Link](https://ieeexplore.ieee.org/document/10157773)  
10. Deep Learning for Brain Tumor Classification: A Review, *MDPI Sensors* (2024).  
11. CNN-Based Brain Tumor Detection: Enhancing Diagnostic Accuracy, *Nature Biomedical Engineering* (2024).  
12. Machine Learning-Based Brain Tumor Diagnosis Using MRI, *Springer AI in Medicine* (2024).  
13. 3D CNNs for Brain Tumor Segmentation and Classification, *Elsevier Pattern Recognition* (2024).  
14. Transfer Learning Strategies for Brain Tumor Analysis, *Frontiers in AI* (2024).  
15. Explainable AI in Brain Tumor Detection Using Deep Learning, *MDPI Applied Sciences* (2024).  
16. Multi-Modal MRI Analysis for Brain Tumor Recognition, *IEEE Transactions on Medical Imaging* (2024).  
17. Automated Glioma and Meningioma Detection Using Deep CNNs, *Scientific Reports (Nature)* (2024).  
18. Attention Mechanisms in Deep Learning for Brain Tumor Detection, *Elsevier Artificial Intelligence in Healthcare* (2024).  
19. Hybrid CNN and Transformer-Based Brain Tumor Analysis, *Journal of Neural Engineering* (2024).  
20. Real-Time MRI-Based Brain Tumor Segmentation with Deep Learning, *arXiv Preprint* (2024).  

